<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D|Enterprise - Icon (3D)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1d1e18; }
        canvas { display: block; }
    </style>
    <!-- Layer 4: The Engine -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <!-- Layer 3: The Stage -->
    <script type="module">
        import * as THREE from 'three';
        import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';

        // 1. Scene Setup (Layer 1)
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1d1e18);
        scene.fog = new THREE.Fog(0x1d1e18, 5, 15); // Atmosphere for depth

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 3; // Closer zoom for the icon

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting (Studio Setup for Depth)
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        const keyLight = new THREE.DirectionalLight(0xffffff, 1.2); // Main light
        keyLight.position.set(5, 5, 5);
        scene.add(keyLight);

        const rimLight = new THREE.DirectionalLight(0xffffff, 1); // Back light for separation
        rimLight.position.set(0, 5, -5);
        scene.add(rimLight);

        const fillLight = new THREE.PointLight(0x8e99a3, 0.5); // Cool fill from side
        fillLight.position.set(-5, 0, 2);
        scene.add(fillLight);

        // 2. The Icon (Layer 4 Component)
        function createRoundedSquare(width, height, radius, color) {
            const shape = new THREE.Shape();
            const x = -width/2, y = -height/2;
            
            shape.moveTo(x + radius, y);
            shape.lineTo(x + width - radius, y);
            shape.quadraticCurveTo(x + width, y, x + width, y + radius);
            shape.lineTo(x + width, y + height - radius);
            shape.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            shape.lineTo(x + radius, y + height);
            shape.quadraticCurveTo(x, y + height, x, y + height - radius);
            shape.lineTo(x, y + radius);
            shape.quadraticCurveTo(x, y, x + radius, y);

            const extrudeSettings = { depth: 0.2, bevelEnabled: false };
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.center();

            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                metalness: 0.3,
                roughness: 0.4
            });
            
            return new THREE.Mesh(geometry, material);
        }

        // Create the Icon Base (Purple from original SVG)
        const icon = createRoundedSquare(1.5, 1.5, 0.3, 0x7936ba);
        scene.add(icon);

        // 3. The Face (The "D" Logo)
        const pathData = "M370.62,167.71c-8.49-2.46-17.29-3.71-26.13-3.71h-87.08c-24.84.13-48.62,10.1-66.13,27.73-17.51,17.62-27.32,41.47-27.29,66.31l.25,149.3c.08,24.84,9.99,48.63,27.56,66.19,17.57,17.55,41.38,27.43,66.22,27.48h87.08c8.84,0,17.64-1.27,26.13-3.78,37.73-8.09,71.54-28.9,95.77-58.93,24.23-30.04,37.41-67.48,37.34-106.07-.07-38.59-13.39-75.99-37.74-105.93-24.34-29.94-58.23-50.62-95.99-58.57ZM348.82,415l-88.57.35c-.9.07-1.81-.04-2.67-.33-.86-.29-1.65-.74-2.33-1.34-.67-.6-1.21-1.32-1.6-2.13-.39-.81-.61-1.69-.65-2.59l-.25-143.45c.1-1.8.9-3.49,2.23-4.71,1.33-1.22,3.08-1.87,4.89-1.81h88.73c42.68,2.55,76.55,36.42,76.55,77.9s-33.52,75.37-76.33,78.1Z";
        const svgMarkup = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 667 667"><path d="${pathData}" /></svg>`;

        const loader = new SVGLoader();
        const svgData = loader.parse(svgMarkup);

        svgData.paths.forEach(path => {
            const shapes = path.toShapes(true);
            shapes.forEach(shape => {
                const geom = new THREE.ExtrudeGeometry(shape, { depth: 20, bevelEnabled: false });
                const mat = new THREE.MeshStandardMaterial({ color: 0xd1d1d1, metalness: 0.5, roughness: 0.2 });
                const mesh = new THREE.Mesh(geom, mat);

                // Transform to fit on the 1.5x1.5 square
                const s = 0.0022;
                mesh.scale.set(s, -s, s); // Flip Y
                
                // Center on the face
                mesh.position.set(-0.73, 0.73, 0.11); // z=0.11 to sit slightly proud of the base surface (0.1)

                icon.add(mesh); // Attach to the rotating icon
            });
        });

        // 4. The Marker (The "Bow" / Arc)
        function createCornerArc(radius, thickness, color, startAngle, endAngle) {
            const shape = new THREE.Shape();
            
            shape.absarc(0, 0, radius, startAngle, endAngle, false);
            shape.absarc(0, 0, radius - thickness, endAngle, startAngle, true);
            
            const extrudeSettings = { depth: 0.05, bevelEnabled: false };
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            
            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                metalness: 0.5,
                roughness: 0.2
            });
            
            return new THREE.Mesh(geometry, material);
        }

        // Corner Center Calculation
        // Width 1.5, Radius 0.3.
        // Center of corner circle is at +/- (0.75 - 0.3) = +/- 0.45
        const cx = 0.45;
        const cy = 0.45;

        // Front Marker (Top-Left) -> Quadrant II (PI/2 to PI)
        const frontArc = createCornerArc(0.25, 0.05, 0xd1d1d1, Math.PI/2, Math.PI);
        frontArc.position.set(-cx, cy, 0.11);
        icon.add(frontArc);

        // Interaction Setup
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(-100, -100); // Start off-screen

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Raycasting for hover effect
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(icon, true);
            const isHovered = intersects.length > 0;

            if (isHovered) {
                // Smoothly rotate to face viewer (nearest multiple of 2PI)
                const targetX = Math.round(icon.rotation.x / (Math.PI * 2)) * (Math.PI * 2);
                const targetY = Math.round(icon.rotation.y / (Math.PI * 2)) * (Math.PI * 2);
                
                icon.rotation.x = THREE.MathUtils.lerp(icon.rotation.x, targetX, 0.1);
                icon.rotation.y = THREE.MathUtils.lerp(icon.rotation.y, targetY, 0.1);
                icon.rotation.z = THREE.MathUtils.lerp(icon.rotation.z, 0, 0.1);
            } else {
                // Slow rotation to show 3D form
                icon.rotation.y += 0.01;
                icon.rotation.x += 0.005;
            }

            renderer.render(scene, camera);
        }
        animate();

        // Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
