<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D|Enterprise - Icon (3D)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1d1e18; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* Layer 3: UI Overlays */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to 3D */
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding: 2rem;
            box-sizing: border-box;
        }

        .chat-bubble {
            position: absolute;
            bottom: 20px; /* Start above the anchor */
            left: 0;
            background: rgba(255, 255, 255, 0.9);
            color: #1d1e18;
            padding: 1rem 1.5rem;
            border-radius: 1rem 1rem 1rem 0; /* Point bottom-left */
            max-width: 300px;
            width: max-content;
            opacity: 0;
            transform: translateY(10px) scale(0.9);
            transition: opacity 0.4s, transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            font-weight: 500;
            pointer-events: none;
        }

        .chat-bubble.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        #status-log {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 300px;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            pointer-events: auto;
            scrollbar-width: thin;
            scrollbar-color: #ff8c00 rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 4px;
            z-index: 1000; /* Ensure it's on top */
            color: #ff8c00; /* Default text color fallback */
        }
        
        .log-entry {
            line-height: 1.4;
        }
        
        .log-emote { color: #ff8c00; } /* Orange for Actions/Emotes */
        .log-speak { color: #ffffff; } /* White for Speech */
        .log-grey { color: #888888; } /* Grey for Standard Moves */
        .log-green { color: #00ff00; } /* Green for Success/Interaction */
        
        #status-log::-webkit-scrollbar {
            width: 6px;
        }
        #status-log::-webkit-scrollbar-thumb {
            background-color: #ff8c00;
            border-radius: 3px;
        }

        #mood-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 8px;
            min-width: 120px;
            pointer-events: none;
            color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: opacity 0.3s;
        }

        #mood-label {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 6px;
            letter-spacing: 0.5px;
            text-transform: capitalize;
        }

        #mood-bar-container {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        #mood-bar {
            width: 100%;
            height: 100%;
            background: #7936ba;
            transform-origin: left;
            transition: width 0.1s linear;
        }
    </style>
    <!-- Layer 4: The Engine -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <!-- Layer 3: The Stage -->
    <div id="ui-layer">
        <div id="mood-indicator">
            <div id="mood-label">Neutral</div>
            <div id="mood-bar-container">
                <div id="mood-bar"></div>
            </div>
        </div>
        <div id="status-log"></div>
        <div id="chat-anchor" style="position: absolute; top: 0; left: 0; width: 0; height: 0; pointer-events: none; z-index: 2000;">
            <div id="chat-bubble" class="chat-bubble">Hello? Is anyone there?</div>
        </div>
    </div>
    <script type="module">
        import * as THREE from 'three';
        import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';

        // 1. Scene Setup (Layer 1)
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1d1e18);
        scene.fog = new THREE.Fog(0x1d1e18, 5, 15); // Atmosphere for depth

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 3; // Closer zoom for the icon

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting (Studio Setup for Depth)
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        const keyLight = new THREE.DirectionalLight(0xffffff, 1.2); // Main light
        keyLight.position.set(5, 5, 5);
        scene.add(keyLight);

        const rimLight = new THREE.DirectionalLight(0xffffff, 1); // Back light for separation
        rimLight.position.set(0, 5, -5);
        scene.add(rimLight);

        const fillLight = new THREE.PointLight(0x8e99a3, 0.5); // Cool fill from side
        fillLight.position.set(-5, 0, 2);
        scene.add(fillLight);

        // 2. The Icon (Layer 4 Component)
        function createRoundedSquare(width, height, radius, color) {
            const shape = new THREE.Shape();
            const x = -width/2, y = -height/2;
            
            shape.moveTo(x + radius, y);
            shape.lineTo(x + width - radius, y);
            shape.quadraticCurveTo(x + width, y, x + width, y + radius);
            shape.lineTo(x + width, y + height - radius);
            shape.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            shape.lineTo(x + radius, y + height);
            shape.quadraticCurveTo(x, y + height, x, y + height - radius);
            shape.lineTo(x, y + radius);
            shape.quadraticCurveTo(x, y, x + radius, y);

            const extrudeSettings = { depth: 0.2, bevelEnabled: false };
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.center();

            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                metalness: 0.3,
                roughness: 0.4
            });
            
            return new THREE.Mesh(geometry, material);
        }

        // Create the Icon Base (Purple from original SVG)
        const icon = createRoundedSquare(1.5, 1.5, 0.3, 0x7936ba);
        scene.add(icon);

        // 3. The Face (The "D" Logo)
        const pathData = "M370.62,167.71c-8.49-2.46-17.29-3.71-26.13-3.71h-87.08c-24.84.13-48.62,10.1-66.13,27.73-17.51,17.62-27.32,41.47-27.29,66.31l.25,149.3c.08,24.84,9.99,48.63,27.56,66.19,17.57,17.55,41.38,27.43,66.22,27.48h87.08c8.84,0,17.64-1.27,26.13-3.78,37.73-8.09,71.54-28.9,95.77-58.93,24.23-30.04,37.41-67.48,37.34-106.07-.07-38.59-13.39-75.99-37.74-105.93-24.34-29.94-58.23-50.62-95.99-58.57ZM348.82,415l-88.57.35c-.9.07-1.81-.04-2.67-.33-.86-.29-1.65-.74-2.33-1.34-.67-.6-1.21-1.32-1.6-2.13-.39-.81-.61-1.69-.65-2.59l-.25-143.45c.1-1.8.9-3.49,2.23-4.71,1.33-1.22,3.08-1.87,4.89-1.81h88.73c42.68,2.55,76.55,36.42,76.55,77.9s-33.52,75.37-76.33,78.1Z";
        const svgMarkup = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 667 667"><path d="${pathData}" /></svg>`;

        const loader = new SVGLoader();
        const svgData = loader.parse(svgMarkup);

        svgData.paths.forEach(path => {
            const shapes = path.toShapes(true);
            shapes.forEach(shape => {
                const geom = new THREE.ExtrudeGeometry(shape, { depth: 20, bevelEnabled: false });
                const mat = new THREE.MeshStandardMaterial({ color: 0xd1d1d1, metalness: 0.5, roughness: 0.2 });
                const mesh = new THREE.Mesh(geom, mat);

                // Transform to fit on the 1.5x1.5 square
                const s = 0.0022;
                mesh.scale.set(s, -s, s); // Flip Y
                
                // Center on the face
                mesh.position.set(-0.73, 0.73, 0.11); // z=0.11 to sit slightly proud of the base surface (0.1)

                icon.add(mesh); // Attach to the rotating icon
            });
        });

        // 4. The Marker (The "Bow" / Arc)
        function createCornerArc(radius, thickness, color, startAngle, endAngle) {
            const shape = new THREE.Shape();
            
            shape.absarc(0, 0, radius, startAngle, endAngle, false);
            shape.absarc(0, 0, radius - thickness, endAngle, startAngle, true);
            
            const extrudeSettings = { depth: 0.05, bevelEnabled: false };
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            
            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                metalness: 0.5,
                roughness: 0.2
            });
            
            return new THREE.Mesh(geometry, material);
        }

        // Corner Center Calculation
        // Width 1.5, Radius 0.3.
        // Center of corner circle is at +/- (0.75 - 0.3) = +/- 0.45
        const cx = 0.45;
        const cy = 0.45;

        // Front Marker (Top-Left) -> Quadrant II (PI/2 to PI)
        const frontArc = createCornerArc(0.25, 0.05, 0xd1d1d1, Math.PI/2, Math.PI);
        frontArc.position.set(-cx, cy, 0.11);
        icon.add(frontArc);

        // 5. The Toy (The Ball)
        const ballGeometry = new THREE.SphereGeometry(0.2, 32, 32);
        const ballMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 }); // Gold ball
        const ball = new THREE.Mesh(ballGeometry, ballMaterial);
        ball.visible = false;
        scene.add(ball);

        // 6. The Decision Engine (The Brain)
        class DecisionEngine {
            constructor(toyMesh) {
                this.memory = []; 
                this.particles = []; 
                this.currentPlan = null; 
                this.isThinking = false;
                this.thinkingEndTime = 0;
                
                // State Tracking
                this.lastInteractionTime = Date.now();
                this.hasGreeted = false;
                this.chatElement = document.getElementById('chat-bubble');
                this.chatAnchor = document.getElementById('chat-anchor');
                
                // Mood UI
                this.moodLabel = document.getElementById('mood-label');
                this.moodBar = document.getElementById('mood-bar');
                this.currentMood = { name: 'Neutral', endTime: 0, duration: 0 };

                // Toy System
                this.toy = {
                    mesh: toyMesh,
                    active: false,
                    stats: JSON.parse(localStorage.getItem('toyStats')) || { plays: 0 },
                    kickCount: 0,
                    ballVelocity: new THREE.Vector3(0, 0, 0),
                    cooldown: 0
                };

                // Attention System
                this.attentionState = 'NONE'; // NONE, WATCHING, CENTERED
                this.attentionTimeout = 0;

                // Emotion System
                this.emotions = {
                    // Heavy/Long
                    'ANGER': { color: 0xff0000, duration: 4000, message: "Grrr..." },
                    'PASSION': { color: 0xc71585, duration: 4000, message: "<3" }, // Deep Pink -> Medium Violet Red
                    'HAPPY': { color: 0xffd700, duration: 3500, message: ":D" },
                    'SAD': { color: 0x1e90ff, duration: 4000, message: ":(" }, // Royal Blue -> Dodger Blue
                    'TIRED': { color: 0x708090, duration: 4500, message: "..." }, // New: Slate Gray
                    
                    // Light/Short
                    'GLAD': { color: 0x98fb98, duration: 1500, message: "^_^" }, // Pale Green
                    'POSITIVE': { color: 0x00ff00, duration: 1500, message: "+" }, // Lime
                    'NEGATIVE': { color: 0x696969, duration: 1500, message: "-" }, // Dim Gray
                    'YES': { color: 0x00ced1, duration: 1000, message: "Yes!" }, // Dark Turquoise
                    'NO': { color: 0xff4500, duration: 1000, message: "No." }, // Orange Red
                    
                    // Complex
                    'CONFUSED': { color: 0xda70d6, duration: 3000, message: "?" }, // Orchid
                    'CURIOUS': { color: 0x20b2aa, duration: 2500, message: "O.o" }, // Light Sea Green
                    'EXCITED': { color: 0xff69b4, duration: 2000, message: "!!!" }, // Hot Pink
                    'SICK': { color: 0x9acd32, duration: 3000, message: "x_x" } // Yellow Green
                };
                
                this.statusLog = document.getElementById('status-log');
                this.logStatus("System Initialized.");
            }

            logStatus(message, type = 'default') {
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                if (type !== 'default') entry.classList.add(`log-${type}`);

                const time = new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
                entry.innerText = `[${time}] ${message}`;
                this.statusLog.appendChild(entry);
                this.statusLog.scrollTop = this.statusLog.scrollHeight;
                this.emotionStats = JSON.parse(localStorage.getItem('emotionStats')) || {};
            }

            updateMoodUI(name, color, duration) {
                this.moodLabel.innerText = name;
                this.moodBar.style.backgroundColor = '#' + color.getHexString();
                
                // Reset animation
                this.moodBar.style.transition = 'none';
                this.moodBar.style.width = '100%';
                
                // Force reflow
                void this.moodBar.offsetWidth;
                
                // Start depletion
                this.moodBar.style.transition = `width ${duration}ms linear`;
                this.moodBar.style.width = '0%';
                
                this.currentMood = {
                    name: name,
                    endTime: Date.now() + duration,
                    duration: duration
                };
            }

            handleUserClick() {
                const now = Date.now();
                this.lastInteractionTime = now;

                if (this.attentionState === 'NONE') {
                    // First Click: Stop and Look
                    this.attentionState = 'WATCHING';
                    this.currentPlan = null; // Stop AI
                    this.isThinking = false;
                    this.attentionTimeout = now + 5000;
                    
                    this.chatElement.innerText = "Yes?";
                    this.chatElement.classList.add('visible');
                } else if (this.attentionState === 'WATCHING') {
                    // Second Click: Come to Center
                    this.attentionState = 'CENTERED';
                    this.attentionTimeout = now + 5000;
                    this.chatElement.innerText = "I'm listening.";
                } else {
                    // Already Centered? Refresh timer
                    this.attentionTimeout = now + 5000;
                }
            }

            // NEW: Physics & Sensor Update Loop (Called every frame)
            update(time, iconPosition) {
                // 1. Ball Physics (Simple friction & bounce)
                if (this.toy.active) {
                    // Apply Velocity
                    if (this.toy.ballVelocity.lengthSq() > 0.0001) {
                        this.toy.mesh.position.add(this.toy.ballVelocity);
                        this.toy.ballVelocity.multiplyScalar(0.95); // Friction
                        
                        // Wall bounce (Simple bounds)
                        if (Math.abs(this.toy.mesh.position.x) > 3.5) this.toy.ballVelocity.x *= -0.8;
                        if (Math.abs(this.toy.mesh.position.y) > 2.5) this.toy.ballVelocity.y *= -0.8;
                        if (Math.abs(this.toy.mesh.position.z) > 2.0) this.toy.ballVelocity.z *= -0.8;
                        
                        // Rotation based on movement
                        this.toy.mesh.rotation.x += this.toy.ballVelocity.z * 2;
                        this.toy.mesh.rotation.z -= this.toy.ballVelocity.x * 2;
                    }

                    // 2. Collision Detection (Icon vs Ball)
                    const dist = iconPosition.distanceTo(this.toy.mesh.position);
                    if (dist < 0.8) {
                        this.handleBallCollision();
                    }
                }

                if (this.toy.cooldown > 0) this.toy.cooldown--;
            }

            handleBallCollision() {
                // Debounce
                if (this.toy.cooldown > 0) return;

                // Decide: Kick or Collect?
                // Chance to collect increases with kicks. 
                // 0 kicks = 0% chance. 10 kicks = 100% chance.
                const collectChance = this.toy.kickCount * 0.1; 
                
                if (Math.random() < collectChance) {
                    // COLLECT
                    this.logStatus("Got Ball!", 'green');
                    this.toy.active = false;
                    this.toy.mesh.visible = false;
                    this.toy.stats.plays++;
                    localStorage.setItem('toyStats', JSON.stringify(this.toy.stats));
                    
                    // Celebration
                    this.currentPlan = null; 
                    this.particles = [this.createAbility('TRICK_BOUNCE')]; 
                    this.particles[0].message = "Got it!";
                    this.isThinking = false; // Force immediate rethink
                } else {
                    // KICK
                    this.logStatus("Hit Ball!", 'green');
                    this.toy.kickCount++;
                    this.toy.cooldown = 30; // Ignore collision for 0.5s
                    
                    // Kick Direction: Random "Shot"
                    const kickDir = new THREE.Vector3(
                        (Math.random() - 0.5),
                        (Math.random() - 0.5),
                        (Math.random() - 0.5)
                    ).normalize();
                    
                    const kickStrength = 0.1 + Math.random() * 0.2;
                    this.toy.ballVelocity = kickDir.multiplyScalar(kickStrength);
                    
                    // AI Reaction: Cancel plan to chase the new position
                    this.currentPlan = null;
                    this.isThinking = false; 
                }
            }

            // NEW: The Ability Library (Pre-defined sequences)
            createAbility(type) {
                const ability = {
                    isAbility: true,
                    type: type,
                    waitBefore: 500,
                    duration: 2000, // Default
                    message: null,
                    // Default Target (Overridden by specific abilities)
                    target: {
                        position: new THREE.Vector3(0, 0, 0),
                        rotationSpeed: { x: 0, y: 0 },
                        scale: new THREE.Vector3(1, 1, 1),
                        colorShift: 0.5,
                        specialEffect: null,
                        lookAtCamera: false,
                        colorOverride: null
                    }
                };

                switch(type) {
                    case 'EMOTE_ALERT':
                        ability.duration = 2500;
                        ability.target.colorOverride = new THREE.Color(0xff4400); // Red/Orange
                        ability.target.position.set(0, 0, 2); // Come closer
                        ability.target.lookAtCamera = true; 
                        ability.message = "!";
                        break;
                    
                    case 'TRICK_BOUNCE':
                        ability.duration = 3000;
                        ability.target.specialEffect = 'BOUNCE';
                        ability.target.colorShift = 0.8; // Shift towards pink
                        break;

                    case 'TRICK_SPIN':
                        ability.duration = 1500;
                        ability.target.specialEffect = 'SPIN';
                        ability.target.rotationSpeed = { x: 0, y: 0.5 }; // Fast Y spin
                        break;

                    case 'TRICK_FLIP': // New
                        ability.duration = 1500;
                        ability.target.specialEffect = 'FLIP';
                        ability.target.rotationSpeed = { x: 0.5, y: 0 }; // Fast X spin
                        break;

                    case 'TRICK_SHAKE': // New
                        ability.duration = 1000;
                        ability.target.specialEffect = 'SHAKE';
                        break;

                    case 'TRICK_PULSE': // New
                        ability.duration = 2000;
                        ability.target.specialEffect = 'PULSE';
                        break;

                    case 'HIDE': // New
                        ability.duration = 3000;
                        ability.target.scale = new THREE.Vector3(0.1, 0.1, 0.1);
                        ability.message = "Hiding...";
                        break;

                    case 'SUMMON_TOY':
                        ability.duration = 1000;
                        ability.target.specialEffect = 'SUMMON';
                        ability.message = "I want to play!"; // This will be logged as speech
                        break;

                    case 'SPEAK': // New Generic Speak Ability
                        ability.duration = 3000;
                        ability.target.lookAtCamera = true;
                        ability.message = "I am learning to speak."; // Default placeholder
                        break;

                    case 'CHANGE_COLOR': // Voluntary (Desire)
                        ability.duration = 2000;
                        ability.target.colorShift = Math.random(); // Pick a random hue preference
                        ability.message = null; 
                        break;

                    case 'MOOD_REFLEX': // Involuntary (Reaction)
                        // Simulates a mood swing or reaction
                        const moods = Object.keys(this.emotions);
                        const randomMood = moods[Math.floor(Math.random() * moods.length)];
                        const emo = this.emotions[randomMood];
                        
                        ability.duration = emo.duration;
                        ability.target.colorOverride = new THREE.Color(emo.color);
                        ability.target.lookAtCamera = true; // Reflexively look at user
                        ability.message = null; // Silent emotion for now
                        ability.mood = randomMood; // Store for memory
                        break;
                }
                return ability;
            }

            // The "Blow": Generate chaos based on INTENT
            blowDust(intent) {
                this.particles = [];
                const particleCount = 50;

                // 10% chance to inject a Special Ability into the cloud if IDLE
                // If we have played a lot, maybe we want to play more? (Bias)
                const playBias = Math.min(this.toy.stats.plays * 0.01, 0.2); // Cap at 20% bonus
                
                if (intent === 'IDLE' && !this.toy.active && Math.random() > (0.7 - playBias)) {
                    const tricks = [
                        'TRICK_BOUNCE', 'TRICK_SPIN', 'TRICK_FLIP', 'TRICK_SHAKE', 'TRICK_PULSE', 
                        'HIDE', 'SUMMON_TOY', 'CHANGE_COLOR', 'MOOD_REFLEX', 'SPEAK'
                    ];
                    const randomTrick = tricks[Math.floor(Math.random() * tricks.length)];
                    this.particles.push(this.createAbility(randomTrick));
                }

                // Special Case: GREET is now a specific Ability
                if (intent === 'GREET') {
                    const greet = this.createAbility('SPEAK');
                    greet.message = "Hello? I'm waiting for input...";
                    // Override target to be bottom-left (classic greeting spot)
                    greet.target.position.set(
                        -1.5 - Math.random(),
                        -1.0 - Math.random() * 0.5,
                        1 + Math.random()
                    );
                    this.particles.push(greet);
                    return; // Skip chaos generation
                }

                for(let i=0; i<particleCount; i++) {
                    let p = {
                        // Common traits
                        rX: (Math.random() - 0.5) * 0.05, 
                        rY: (Math.random() - 0.5) * 0.05, 
                        scale: 0.8 + Math.random() * 0.4, 
                        colorShift: Math.random(),
                        duration: 2000 + Math.random() * 3000,
                        isAbility: false // Mark standard particles
                    };

                    // Context-Aware Generation
                    if (intent === 'FETCH') {
                        // Intent: Go to the Ball!
                        // Target area: Near the ball's position
                        const ballPos = this.toy.mesh.position;
                        p.x = ballPos.x + (Math.random() - 0.5) * 0.5; // Precision
                        p.y = ballPos.y + (Math.random() - 0.5) * 0.5;
                        p.z = ballPos.z + (Math.random() - 0.5) * 0.5;
                        p.waitBefore = 0; // Urgent!
                        p.message = "Mine!";
                        p.actionType = 'MOVE';
                        p.duration = 1000 + Math.random() * 1000; // Fast
                    }
                    else {
                        // Intent: IDLE (Random drift)
                        p.x = (Math.random() - 0.5) * 3; 
                        p.y = (Math.random() - 0.5) * 3; 
                        p.z = (Math.random() - 0.5) * 2;
                        p.waitBefore = 0;
                        p.message = null;
                        p.actionType = 'MOVE';
                    }

                    this.particles.push(p);
                }
            }

            // The "Reflex": Determine involuntary color/mood response
            consultReflex() {
                // 30% chance to stay "Unchanged" (Purple)
                if (Math.random() < 0.3) return null;

                const moods = Object.keys(this.emotions);
                const randomMood = moods[Math.floor(Math.random() * moods.length)];
                const emo = this.emotions[randomMood];

                // Determine Animation Speed based on duration/mood
                // Short duration = Fast transition (Flash)
                // Long duration = Slow transition (Burn)
                let speed = 0.05;
                if (emo.duration < 2000) speed = 0.1; // Fast
                if (emo.duration > 3500) speed = 0.02; // Slow

                return {
                    color: new THREE.Color(emo.color),
                    duration: emo.duration,
                    speed: speed,
                    name: randomMood
                };
            }

            // The "Instinct": Choose the path
            consultTheDust(time) {
                // 1. Check Environment / User State
                const timeSinceInteraction = Date.now() - this.lastInteractionTime;
                let currentIntent = 'IDLE';

                // Priority 1: Toy is active? FETCH IT.
                if (this.toy.active) {
                    currentIntent = 'FETCH';
                    // Collision logic moved to update()
                }
                // Priority 2: Greeting
                else if (timeSinceInteraction > 5000 && !this.hasGreeted) {
                    currentIntent = 'GREET';
                }

                // If we have a plan running, check if it's done
                if (this.currentPlan) {
                    if (time < this.currentPlan.endTime) return;
                    // Plan finished? Clear it.
                    this.currentPlan = null;
                }

                // Start Thinking (Blow Dust)
                if (!this.isThinking) {
                    this.blowDust(currentIntent);
                    this.isThinking = true;
                    this.thinkingEndTime = time + (500 + Math.random() * 1000); 
                    return;
                }

                // Wait for "Pattern Lock" (Thinking time)
                if (time < this.thinkingEndTime) return; 

                // SNAPSHOT! Select best particle.
                this.isThinking = false;
                
                // Selection Logic
                let bestParticle = this.particles.find(p => p.isAbility);
                
                if (!bestParticle) {
                    bestParticle = this.particles[Math.floor(Math.random() * this.particles.length)];
                }
                
                // Consult Reflex System
                const reflex = this.consultReflex();

                // Commit Plan
                if (bestParticle.isAbility) {
                    // Log based on ability type
                    if (bestParticle.type === 'SPEAK') {
                        this.logStatus(bestParticle.message, 'speak');
                    } else {
                        this.logStatus(`Running Ability: ${bestParticle.type}`, 'emote');
                    }

                    this.currentPlan = {
                        type: bestParticle.type,
                        startTime: time + bestParticle.waitBefore,
                        endTime: time + bestParticle.waitBefore + bestParticle.duration,
                        message: bestParticle.message,
                        target: bestParticle.target
                    };
                    
                    // Apply Reflex if not already overridden by the ability itself
                    if (!this.currentPlan.target.colorOverride && reflex) {
                        this.currentPlan.target.colorOverride = reflex.color;
                        this.currentPlan.target.colorLerp = reflex.speed;
                        this.currentPlan.reflexEndTime = this.currentPlan.startTime + reflex.duration;
                        
                        // Update UI
                        this.updateMoodUI(reflex.name, reflex.color, reflex.duration);
                    }

                    // Execute Ability Side Effects
                    if (bestParticle.type === 'SUMMON_TOY') {
                        this.logStatus("I want to play!", 'speak'); // Explicitly log the speech part
                        this.toy.active = true;
                        this.toy.kickCount = 0;
                        this.toy.ballVelocity.set(0,0,0);
                        this.toy.mesh.visible = true;
                        this.toy.mesh.position.set(
                            (Math.random() - 0.5) * 4,
                            (Math.random() - 0.5) * 3,
                            (Math.random() - 0.5) * 2
                        );
                    } else if (bestParticle.type === 'MOOD_REFLEX') {
                        // Memory: Remember this mood swing
                        const mood = bestParticle.mood;
                        if (mood) {
                            this.emotionStats[mood] = (this.emotionStats[mood] || 0) + 1;
                            localStorage.setItem('emotionStats', JSON.stringify(this.emotionStats));
                            
                            // Update UI for explicit mood ability
                            const emo = this.emotions[mood];
                            this.updateMoodUI(mood, new THREE.Color(emo.color), emo.duration);
                        }
                    }
                } else {
                    // Standard Particle Mapping
                    let actionDesc = "Move";
                    if (bestParticle.scale > 1.1) actionDesc += ", Grow";
                    else if (bestParticle.scale < 0.9) actionDesc += ", Shrink";
                    if (Math.abs(bestParticle.rX) > 0.01 || Math.abs(bestParticle.rY) > 0.01) actionDesc += ", Rotate";
                    
                    this.logStatus(`Decided to: ${actionDesc}`, 'grey');

                    this.currentPlan = {
                        type: bestParticle.actionType,
                        startTime: time + bestParticle.waitBefore,
                        endTime: time + bestParticle.waitBefore + bestParticle.duration,
                        message: bestParticle.message,
                        target: {
                            position: new THREE.Vector3(bestParticle.x, bestParticle.y, bestParticle.z),
                            rotationSpeed: { x: bestParticle.rX, y: bestParticle.rY },
                            scale: new THREE.Vector3(bestParticle.scale, bestParticle.scale, bestParticle.scale),
                            colorShift: bestParticle.colorShift,
                            specialEffect: null,
                            lookAtCamera: false,
                            colorOverride: null // Will be set by reflex below
                        }
                    };

                    if (reflex) {
                        this.currentPlan.target.colorOverride = reflex.color;
                        this.currentPlan.target.colorLerp = reflex.speed;
                        this.currentPlan.reflexEndTime = this.currentPlan.startTime + reflex.duration;
                    }
                }

                if (currentIntent === 'GREET') {
                    this.hasGreeted = true;
                }
            }

            getInstruction(time) {
                // Check Attention Timeout
                if (this.attentionState !== 'NONE') {
                    if (Date.now() > this.attentionTimeout) {
                        this.attentionState = 'NONE';
                        this.chatElement.classList.remove('visible');
                    } else {
                        // Return Override Instruction
                        return { 
                            state: 'override', 
                            mode: this.attentionState 
                        };
                    }
                }

                this.consultTheDust(time);
                
                // If we are in the "Wait Before" phase of a plan
                if (this.currentPlan && time < this.currentPlan.startTime) {
                    return { state: 'waiting' };
                }

                if (this.isThinking) {
                    return { state: 'thinking' };
                }

                if (this.currentPlan) {
                    // Check Reflex Expiry
                    if (this.currentPlan.reflexEndTime && time > this.currentPlan.reflexEndTime) {
                        this.currentPlan.target.colorOverride = null; // Revert to purple
                    }
                    
                    // Check Mood UI Expiry
                    if (this.currentMood.endTime > 0 && Date.now() > this.currentMood.endTime) {
                        this.moodLabel.innerText = 'Neutral';
                        this.moodBar.style.transition = 'width 0.5s';
                        this.moodBar.style.width = '0%';
                        this.moodBar.style.backgroundColor = '#7936ba';
                        this.currentMood.endTime = 0;
                    }

                    // Trigger UI if needed
                    if (this.currentPlan.type === 'SPEAK' && !this.chatElement.classList.contains('visible')) {
                        this.chatElement.innerText = this.currentPlan.message;
                        this.chatElement.classList.add('visible');
                    } else if (this.currentPlan.type !== 'SPEAK') {
                        this.chatElement.classList.remove('visible');
                    }

                    return { state: 'acting', data: this.currentPlan.target };
                }

                return { state: 'idle' };
            }

            recordInteraction() {
                this.lastInteractionTime = Date.now();
                // If user interacts, hide chat and reset greeting flag maybe?
                // For now, just hide chat
                this.chatElement.classList.remove('visible');
            }
        }

        const brain = new DecisionEngine(ball);

        // Interaction Setup
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(-100, -100); 

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            brain.recordInteraction(); // Notify brain of activity
        });

        // Click to Kick or Attend (User Interaction)
        window.addEventListener('click', (event) => {
            raycaster.setFromCamera(mouse, camera);

            // 1. Check Ball Click
            if (brain.toy.active) {
                const ballIntersects = raycaster.intersectObject(ball);
                if (ballIntersects.length > 0) {
                    // User kicked the ball!
                    const kickDir = new THREE.Vector3(
                        (Math.random() - 0.5),
                        (Math.random() - 0.5),
                        (Math.random() - 0.5)
                    ).normalize();
                    
                    brain.toy.ballVelocity = kickDir.multiplyScalar(0.3);
                    brain.toy.kickCount++; 
                    brain.currentPlan = null;
                    brain.isThinking = false;
                    return; // Ball click takes precedence
                }
            }

            // 2. Check Icon Click
            const iconIntersects = raycaster.intersectObject(icon, true);
            if (iconIntersects.length > 0) {
                brain.handleUserClick();
            }
        });

        // Animation Loop
        function animate(time) {
            requestAnimationFrame(animate);
            
            // AI Control: Consult the Dust
            brain.update(time, icon.position); 
            const instruction = brain.getInstruction(time);

            if (instruction.state === 'override') {
                // User Attention Override
                // Face Camera
                const targetX = Math.round(icon.rotation.x / (Math.PI * 2)) * (Math.PI * 2);
                const targetY = Math.round(icon.rotation.y / (Math.PI * 2)) * (Math.PI * 2);
                icon.rotation.x = THREE.MathUtils.lerp(icon.rotation.x, targetX, 0.1);
                icon.rotation.y = THREE.MathUtils.lerp(icon.rotation.y, targetY, 0.1);
                icon.rotation.z = THREE.MathUtils.lerp(icon.rotation.z, 0, 0.1);
                icon.scale.lerp(new THREE.Vector3(1,1,1), 0.1);

                if (instruction.mode === 'CENTERED') {
                    icon.position.lerp(new THREE.Vector3(0,0,0), 0.1);
                } 
                // If WATCHING, we just stop moving (no position update)
            }
            else if (instruction.state === 'thinking') {
                    // Shimmer/Vibrate while thinking
                    icon.rotation.z += 0.05; 
                    // Maybe pulse scale slightly
                    const pulse = 1 + Math.sin(time * 0.01) * 0.05;
                    icon.scale.setScalar(pulse);
                } 
                else if (instruction.state === 'acting') {
                    const target = instruction.data;

                    // 1. Position & Physics Effects
                    if (target.specialEffect === 'BOUNCE') {
                        const bounce = Math.abs(Math.sin(time * 0.005)) * 1.5;
                        icon.position.y = THREE.MathUtils.lerp(icon.position.y, bounce - 1, 0.1);
                        icon.position.x = THREE.MathUtils.lerp(icon.position.x, target.position.x, 0.05);
                        icon.position.z = THREE.MathUtils.lerp(icon.position.z, target.position.z, 0.05);
                    } else {
                        icon.position.lerp(target.position, 0.02);
                    }
                    
                    // 2. Rotation & Physics Effects
                    if (target.specialEffect === 'SHAKE') {
                        icon.rotation.z = Math.sin(time * 0.02) * 0.5; // Wobble
                        icon.rotation.x = THREE.MathUtils.lerp(icon.rotation.x, 0, 0.1);
                        icon.rotation.y = THREE.MathUtils.lerp(icon.rotation.y, 0, 0.1);
                    } else {
                        icon.rotation.x += target.rotationSpeed.x;
                        icon.rotation.y += target.rotationSpeed.y;
                    }
                    
                    // 3. Scale & Physics Effects
                    if (target.specialEffect === 'PULSE') {
                        const pulse = 1 + Math.sin(time * 0.01) * 0.3;
                        icon.scale.setScalar(pulse);
                    } else {
                        icon.scale.lerp(target.scale, 0.02);
                    }

                    // Color Logic
                    if (target.colorOverride) {
                        // Direct Color Override (Reflex/Emotion)
                        const speed = target.colorLerp || 0.05;
                        icon.material.color.lerp(target.colorOverride, speed);
                    } else {
                        // Standard Purple Shift (Breathing)
                        // Brand Purple: 0x7936ba (HSL approx: 270, 55%, 47%)
                        const baseColor = new THREE.Color(0x7936ba);
                        const targetHSL = {};
                        baseColor.getHSL(targetHSL);
                        
                        // Shift hue based on the particle's unique colorShift value
                        targetHSL.h += (target.colorShift - 0.5) * 0.2; // +/- 10% hue shift
                        
                        const currentParams = {};
                        icon.material.color.getHSL(currentParams);
                        
                        // Lerp the HSL values
                        const newH = THREE.MathUtils.lerp(currentParams.h, targetHSL.h, 0.05);
                        icon.material.color.setHSL(newH, targetHSL.s, targetHSL.l);
                    }
                }

            // Update Chat Bubble Position
            if (brain.chatElement.classList.contains('visible')) {
                // Calculate position above the icon's "head" (Local Y axis)
                const vector = new THREE.Vector3(0, 1.2, 0);
                vector.applyMatrix4(icon.matrixWorld);
                vector.project(camera);

                const x = (vector.x * .5 + .5) * window.innerWidth;
                const y = (-(vector.y * .5) + .5) * window.innerHeight;

                brain.chatAnchor.style.left = `${x}px`;
                brain.chatAnchor.style.top = `${y}px`;
            }

            renderer.render(scene, camera);
        }
        animate(0);

        // Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>